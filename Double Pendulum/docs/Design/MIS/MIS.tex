\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{mathtools}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}

\newcommand{\progname}{Double Pendulum}

\begin{document}

\title{Module Interface Specification for Double Pendulum}

\author{Zhi Zhang}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Nov.13 & 1.0 & Initial Draft\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \url{https://github.com/best-zhang-zhi/CAS741Project/blob/master/Double%20Pendulum/docs/SRS/SRS.pdf}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for Double Pendulum, a software which determines the motion of a double pendulum given the initial conditions from user inputs. 

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/best-zhang-zhi/CAS741Project}.  

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
string & $char^n$ & a sequence of alphanumeric and special characters\\
list & $real^n$ & a list of real numbers\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding Module} & ~ \\
\midrule

\multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} 
& User Input Module\\
& Angular Acceleration Module\\
& Runge Kutta Module\\
& Output Module\\

\midrule

\multirow{3}{0.3\textwidth}{Software Decision Module} 
& GUI Module\\ 
& Graph Module\\  
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage
~\newpage


\section{MIS of User Input Module} \label{UIModule} 
The user input module is responsible for acquiring data from users. The module verifies whether or not the input data meets the constraints, and output the verified data to the Angular Acceleration Module.

\subsection{Module}

Input

\subsection{Uses}
N/A

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
  \item $m_1$: real
  \item $m_2$: real
  \item $L_1$: real
  \item $L_2$: real
  \item $\theta_1$: real
  \item $\theta_2$: real
  \item $g$: real
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{2cm} p{2cm} p{6cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
GetMass1 & real & real & IN\_NEGATIVE\_MASS \\
\hline
GetMass2 & real & real & IN\_NEGATIVE\_MASS \\
\hline
GetLength1 & real & real & IN\_NEGATIVE\_LENGTH \\
\hline
GetLength2 & real & real & IN\_NEGATIVE\_LENGTH \\
\hline
GetAngle1 & real & real & -\\
\hline
GetAngle2 & real & real & - \\
\hline
GetGravityConstant & real & real & IN\_NEGATIVE\_GRAVITY \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
keyboard: users type in the required data using keyboard
\wss{I'm not sure if I should include this}
\subsubsection{Assumptions}
\begin{itemize}
  \item Users only input numerical numbers
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent GetMass1($m_1$):
\begin{itemize}
\item transition: N/A
\item output: $out := self$
\item exception: $exc := m_1 \leq 0 \Rightarrow IN\_NEGATIVE\_MASS$
\end{itemize}

\noindent GetMass2($m_2$):
\begin{itemize}
\item transition: N/A
\item output: $out := self$
\item exception: $exc := m_2 \leq 0 \Rightarrow IN\_NEGATIVE\_MASS$
\end{itemize}

\noindent GetLength1($L_1$):
\begin{itemize}
\item transition: N/A
\item output: $out := self$
\item exception: $exc := L_1 \leq 0 \Rightarrow IN\_NEGATIVE\_LENGTH$
\end{itemize}

\noindent GetLength2($L_2$):
\begin{itemize}
\item transition: N/A
\item output: $out := self$
\item exception: $exc := L_2 \leq 0 \Rightarrow IN\_NEGATIVE\_LENGTH$
\end{itemize}

\noindent GetAngle1($\theta_1$):
\begin{itemize}
\item transition: N/A
\item output: $out := self$
\item exception: N/A
\end{itemize}

\noindent GetAngle2($\theta_2$):
\begin{itemize}
\item transition: N/A
\item output: $out := self$
\item exception: N/A
\end{itemize}


\noindent GetGravityConstant($g$):
\begin{itemize}
\item transition: N/A
\item output: $out := self$
\item exception: $exc := g \leq 0 \Rightarrow IN\_NEGATIVE\_GRAVITY$
\end{itemize}

\subsubsection{Local Functions}
N/A

\newpage


\section{MIS of Angular Acceleration Module} \label{AAModule} 
The angular acceleration module uses data from user input module \ref{UIModule}, and outputs the equations of the angular acceleration. 

\subsection{Module}
Acceleration

\subsection{Uses}
Input

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item ${\theta_1}''$
  \item ${\theta_2}''$
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
getAcc1 & Input & string & - \\
\hline
getAcc2 & Input & string & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A
\subsubsection{Environment Variables}
N/A
\subsubsection{Assumptions}
N/A
\subsubsection{Access Routine Semantics}

\noindent getAcc1($m_1$, $m_2$, $L_1$. $L_2$, $\theta_1$, $\theta_2$, $g$):
\begin{itemize}
\item transition: N/A 
\item output: 
\[{\theta_1}''=\frac{-g(2m_1+m_2)sin\theta_1-m_2gsin(\theta_1-2\theta_2)-2sin(\theta_1-\theta_2)m_2({{\theta_2}'}^2L_2+{{\theta_2}'}^2L_1cos(\theta_1-\theta_2)\big)}{L_1(2m_1+m_2-m_2cos(2\theta_1-2\theta_2))}\]
\item exception: N/A
\end{itemize}

\noindent getAcc2($m_1$, $m_2$, $L_1$. $L_2$, $\theta_1$, $\theta_2$, $g$):
\begin{itemize}
\item transition: N/A 
\item output: 
\[{\theta_2}''=\frac{2sin(\theta_1-\theta_2)({\theta_1}'L_1(m1+m2)+g(m_1+m_2)cos(\theta_1)+{(\theta_2}')^2L_2m_2cos(\theta_1-\theta_2\big)}{L_2(2m_1+m_2-m_2cos(2\theta_1-2\theta_2))}\]
\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}

N/A
\newpage
\section{MIS of Runge Kutta Module} \label{RKModule} 
Multi-variable Rung-kutta algorithm will be used to approximate the angular velocity of the two mass. \cite{RungeKutta} This module outputs two lists of point velocity for each mass. 
\subsection{Module}
RungeKutta
\subsection{Uses}
Acceleration

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item ${\theta_1}'$
  \item ${\theta_2}'$
\end{itemize}
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
getVelocity1 & string & list & - \\
\hline
getVelocity2 & string & list & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item $a_n$ = ${\theta_1}''(0.1,{\theta_1}')$ 
  \item $b_n$ = ${\theta_1}''(0.105,{\theta_1}'+0.005a_n)$
  \item $c_n$ = ${\theta_1}''(0.105,{\theta_1}'+0.005b_n)$
  \item $d_n$ = ${\theta_1}''(0.11,{\theta_1}'+0.01b_n)$

\end{itemize}
\subsubsection{Environment Variables}

N/A
\subsubsection{Assumptions}

N/A
\subsubsection{Access Routine Semantics}

\noindent getVelocity1():
\begin{itemize}
\item transition: N/A 
\item output: $\forall n: \mathbb{Z}| n \in[0..10000]: \theta_1(n+1) = \theta_1(n) + 0.01/6(a_n+2b_n+2c_n+d_n) $
\item exception: N/A
\end{itemize}

\noindent getVelocity2():
\begin{itemize}
\item transition: N/A 
\item output: $\forall n: \mathbb{Z}| n \in[0..10000]: \theta_2(n+1) = \theta_2(n) + 0.01/6(a_n+2b_n+2c_n+d_n) $
\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}

N/A
\newpage


\section{MIS of Output Module} \label{OModule} 
The output module takes the point velocity of two masses, and outputs the point position of them in list form.

\subsection{Module}
Output

\subsection{Uses}
RungeKutta

\subsection{Syntax}

\subsubsection{Exported Constants}
\subsubsection{Exported Constants}
\begin{itemize}
  \item ${\theta_1}$
  \item ${\theta_2}$
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
getPosition1 & list & list & - \\
\hline
getPosition2 & list & list & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A
\subsubsection{Environment Variables}
N/A
\subsubsection{Assumptions}
N/A
\subsubsection{Access Routine Semantics}

\noindent getPosition1($(\theta_1)_n,(\theta_1)_0$):
\begin{itemize}
\item transition: N/A  
\item output: $\forall n: \mathbb{Z}| n \in[1..9999]: \theta_1(n+1) = \theta_1(n-1) + \theta_1(n)$
\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}

N/A

\newpage

\section{MIS of Interval Data Structure Module} \label{IDSModule} 


\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
\item transition: \wss{if appropriate} 
\item output: \wss{if appropriate} 
\item exception: \wss{if appropriate} 
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}

\newpage
\section{MIS of Equation Data Structure Module} \label{EDSModule} 


\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
\item transition: \wss{if appropriate} 
\item output: \wss{if appropriate} 
\item exception: \wss{if appropriate} 
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}

\newpage

\section{MIS of Output Data Structure Module} \label{Module} 


\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
\item transition: \wss{if appropriate} 
\item output: \wss{if appropriate} 
\item exception: \wss{if appropriate} 
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}

\newpage


\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\end{document}